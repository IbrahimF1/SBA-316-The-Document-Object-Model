const questions = [
  {
    text: "Which node is located at the absolute root of the DOM tree structure?",
    options: ["Element", "Text", "Document", "Attribute"],
    answer: "Document"
  },
  {
    text: "Which object sits at the top of the Browser Object Model (BOM) hierarchy?",
    options: ["document", "window", "navigator", "location"],
    answer: "window"
  },
  {
    text: "Which method is considered the most efficient for selecting a DOM element with a specific ID?",
    options: ["querySelector()", "querySelectorAll()", "getElementById()", "getElementsByName()"],
    answer: "getElementById()"
  },
  {
    text: "In JavaScript, how must CSS properties be written when using the .style property?",
    options: ["snake-case", "UPPERCASE", "lowercase", "camelCase"],
    answer: "camelCase"
  },
  {
    text: "Which event fires specifically on the <form> element when a user clicks a submit button?",
    options: ["click", "input", "submit", "change"],
    answer: "submit"
  },
  {
    text: "Which property should be used to retrieve or set content as HTML markup within an element?",
    options: ["textContent", "innerText", "innerHTML", "value"],
    answer: "innerHTML"
  },
  {
    text: "What is the primary difference between an HTMLCollection and a NodeList generated by querySelectorAll?",
    options: ["NodeLists are live", "HTMLCollections are automatically updated", "NodeLists cannot use forEach", "There is no difference"],
    answer: "HTMLCollections are automatically updated"
  },
  {
    text: "Which classList method removes a class if it exists or adds it if it does not?",
    options: ["add()", "remove()", "contains()", "toggle()"],
    answer: "toggle()"
  },
  {
    text: "Which property of the Event object refers to the specific DOM element that triggered the event?",
    options: ["type", "target", "this", "currentTarget"],
    answer: "target"
  },
  {
    text: "Which BOM child object provides information about the current URL of the window?",
    options: ["history", "screen", "location", "navigator"],
    answer: "location"
  },
  {
    text: "Which method of the history object is used to load the previous URL in the history list?",
    options: ["forward()", "go(1)", "back()", "pushState()"],
    answer: "back()"
  },
  {
    text: "Which HTML attribute uses regular expressions to define a pattern that input data must follow?",
    options: ["type", "required", "pattern", "title"],
    answer: "pattern"
  },
  {
    text: "What is the process called where a single event listener handles events for all of its descendants?",
    options: ["Event Bubbling", "Event Capturing", "Event Delegation", "Event Propagation"],
    answer: "Event Delegation"
  },
  {
    text: "What is the correct order of the three phases in the DOM event flow?",
    options: ["Bubbling, Target, Capture", "Capture, Target, Bubbling", "Target, Capture, Bubbling", "Capture, Bubbling, Target"],
    answer: "Capture, Target, Bubbling"
  },
  {
    text: "Why might a developer use a DocumentFragment when creating complex DOM subtrees?",
    options: ["To make the code shorter", "To bypass CSS rules", "To improve performance", "To ensure the code is static"],
    answer: "To improve performance"
  },
  {
    text: "How is event capturing enabled when registering a listener with addEventListener?",
    options: ["Set capture: true in the options object", "It is enabled by default", "Use stopPropagation()", "Call capture() inside the callback"],
    answer: "Set capture: true in the options object"
  },
  {
    text: "Which method prevents an event from continuing to 'bubble' up the parental chain?",
    options: ["preventDefault()", "stopImmediatePropagation()", "stopPropagation()", "removeEventListener()"],
    answer: "stopPropagation()"
  },
  {
    text: "What is required to successfully remove an event listener using removeEventListener?",
    options: ["An anonymous function", "A reference to a named function", "The event type only", "The capture: false option"],
    answer: "A reference to a named function"
  },
  {
    text: "Which input event fires only when a change has been completed and committed (e.g., user moves to a new field)?",
    options: ["input", "change", "submit", "focus"],
    answer: "change"
  },
  {
    text: "Which screen object property returns the height of the screen excluding operating system interface features like the taskbar?",
    options: ["height", "availHeight", "innerHeight", "outerHeight"],
    answer: "availHeight"
  }
];

let currentScore = 0;
let currentStreak = 0;
let currentQuestionIndex = 0;
let isFateUsed = false;
let playerName = "";

const REWARD_BRAVE = 100;
const REWARD_COWARD = 50;
const PENALTY = 100;

const startScreen = document.querySelector('#start-screen');
const gameScreen = document.querySelector('#game-screen');

const scoreDisplay = document.getElementById('score-count')
const streakDisplay = document.getElementById('streak-count')

const questionText = document.getElementById('question-text')
const answerContainer = document.getElementById('answer-container')
const fateBtn = document.getElementById('fate-btn')
const messageBox = document.getElementById('message-box')

function loadQuestion() {
    const currentQuestion = questions[currentQuestionIndex]

    questionText.textContent = currentQuestion.text
    answerContainer.innerHTML = ""
    messageBox.textContent = "Choose wisely..."
    isFateUsed = false
    fateBtn.disabled = false

    const fragment = document.createDocumentFragment()

    for (const option of currentQuestion.options) {
        const button = document.createElement('button')
        button.textContent = option
        button.classList.add('answer-btn')
        fragment.appendChild(button)
    }

    answerContainer.appendChild(fragment)
}

const form = document.querySelector('#start-screen form')
const playerInput = form.querySelector('input')

form.addEventListener('submit', (e) => {
    e.preventDefault()
    playerName = playerInput.value

    startScreen.classList.toggle('hidden')
    gameScreen.classList.toggle('hidden')

    loadQuestion()
})

fateBtn.addEventListener('click', () => {
    const chance = 50 - (currentStreak *10)
    const roll = Math.random() * 100

    isFateUsed = true
    fateBtn.disabled = true

    if (roll < chance) {
        messageBox.textContent = "The stars align..."
        const buttons = answerContainer.children

        for (let btn of buttons) {
            if (btn.textContent == questions[currentQuestionIndex].answer)
                btn.classList.add('correct-border')
        }
    } else {
        messageBox.textContent = "The stars remain silent..."
    }
})

answerContainer.addEventListener('click', (e) => {
    if (!e.target.matches('button'))
        return

    const selectedButton = e.target
    const selectedAnswer = selectedButton.textContent
    const correctAnswer = questions[currentQuestionIndex].answer

    if (selectedAnswer == correctAnswer) {
        selectedButton.classList.add('correct')
        messageBox.textContent = "Correct!"

        if (isFateUsed) {
            currentScore += REWARD_COWARD
        } else {
            currentScore += REWARD_BRAVE
        }

        currentStreak++
    } else {
        selectedButton.classList.add('wrong')
        messageBox.textContent = `Wrong! The answer was: ${correctAnswer}`

        if (isFateUsed)
            currentScore -= PENALTY

        currentStreak = 0
    }

    scoreDisplay.textContent = currentScore
    streakDisplay.textContent = currentStreak

    const allButtons = answerContainer.children
    for (let btn of allButtons)
        btn.disabled = true

    setTimeout(() => {
        currentQuestionIndex++

        if (currentQuestionIndex < questions.length){
            loadQuestion()
        } else {
            alert(`Game Over ${playerName}! Final Score: ${currentScore}`)
            location.reload()
        }
    }, 5000)
})
